theory Implementation  imports Soundness Completeness Termination
begin


text{* les types de donne*}
types ('ni,'nr,'nc) abox_impl = 
  "(('ni,'nr,'nc) fact) list"

types ('ni,'nr,'nc) rule_impl = 
  "(('ni,'nr,'nc) abox_impl) \<Rightarrow> ('ni,'nr,'nc) abox_impl list"

types ('ni,'nr,'nc) abstraction = 
  "(('ni,'nr,'nc) abox_impl \<Rightarrow> ('ni,'nr,'nc) abox)"

types ('ni, 'nr, 'nc) tableau  = 
  "('ni, 'nr, 'nc) abox_impl list"


(* Rules  *)

types ('ni, 'nr, 'nc) appcond = 
  "('ni, 'nr, 'nc) abox_impl \<Rightarrow> ('ni, 'nr, 'nc) fact \<Rightarrow> bool"

types ('ni, 'nr, 'nc) action = 
  "(('ni, 'nr, 'nc) abox_impl * ('ni, 'nr, 'nc) fact * ('ni, 'nr, 'nc) abox_impl) \<Rightarrow>
  ('ni, 'nr, 'nc) abox_impl list"

datatype ('ni, 'nr, 'nc) srule  = 
  Rule " ('ni, 'nr, 'nc) appcond * ('ni, 'nr, 'nc) action"

  (** some properties **)

  (* -- should rather be completeness: no potential solutions are lost.
  constdefs correct_implementation :: "(('ni,'nr,'nc) abox_impl \<Rightarrow> ('ni,'nr,'nc)
  abox) \<Rightarrow> (('ni,'nr,'nc) rule) \<Rightarrow> (('ni,'nr,'nc) rule_impl) \<Rightarrow> bool"
  "correct_implementation abstr r r_impl == \<forall> ai ai'. (r (abstr ai) (abstr ai'))
  \<longrightarrow> ai' \<in> set (r_impl ai) "

  -- corresponds to soundness below constdefs complete_implementation ::
  "(('ni,'nr,'nc) abox_impl \<Rightarrow> ('ni,'nr,'nc) abox) \<Rightarrow> (('ni,'nr,'nc) rule) \<Rightarrow>
  (('ni,'nr,'nc) rule_impl) \<Rightarrow> bool" "complete_implementation abstr r r_impl ==
  \<forall> ai ai'.  ai' \<in> set (r_impl ai) \<longrightarrow> (r (abstr ai) (abstr ai'))" *)
  (* "sound" means: all successor tableaux generated by the rule
   implementation also have to be generated by the rule itself.  *)

  (* "sound" means: all successor tableaux generated by the rule implementation 
   also have to be generated by the rule itself.
  *)

 constdefs 
   sound_rule_impl :: "('ni,'nr,'nc) abstraction
   \<Rightarrow> (('ni,'nr,'nc) rule) \<Rightarrow> (('ni,'nr,'nc) rule_impl) \<Rightarrow> bool"
   "sound_rule_impl abstr r r_impl \<equiv> 
   \<forall> ai ai'. (ai' \<in> set (r_impl ai)) \<longrightarrow> r (abstr ai) (abstr ai')"


   (* "complete" means: all successor tableaux generated by the abstract rule 
   also have to be generated by the rule implementation.
   *)
 constdefs 
   complete_rule_impl :: "('ni,'nr,'nc) abstraction
   \<Rightarrow> (('ni,'nr,'nc) rule) \<Rightarrow> (('ni,'nr,'nc) rule_impl) \<Rightarrow> bool"
   "complete_rule_impl abstr r r_impl \<equiv>
   (\<forall> ab' abi. r (abstr abi) ab' \<longrightarrow> 
   (\<exists> abi'. ab' = abstr abi' \<and> abi'  \<in> set (r_impl abi)))"
 
   (* previous definition was too restrictive
   "complete_rule_impl abstr r r_impl \<equiv>
   \<forall>  ai ai'. (r (abstr ai) (abstr ai')) \<longrightarrow>  ai' \<in> set (r_impl ai) "
   *)


   (* this is other definition we use set inclusion better to not consdere the
   ordre (2 lists are equal if they are identique , ordre also is important) wich
   not considered in set *)

 constdefs 
   complete_rule_impl_set :: "('ni,'nr,'nc) abstraction
   \<Rightarrow> (('ni,'nr,'nc) rule) \<Rightarrow> (('ni,'nr,'nc) rule_impl) \<Rightarrow> bool"
   "complete_rule_impl_set abstr r r_impl \<equiv>
   \<forall>  ai ai'. (r (abstr ai) (abstr ai')) \<longrightarrow>  set ai' \<in>  (set` set (r_impl ai))"
 

   (* see Tableau.thy *)

definition satisfies_abox :: 
  "(('ni Interp_inst) * (('nr, 'nc) Interp) ) \<Rightarrow> (('ni,'nr,'nc) abox) \<Rightarrow> bool"
  where
     "satisfies_abox i ab = (\<forall> f \<in> ab. satisfiable_fact i f)"

definition satisfies_abox_impl :: 
  "('ni,'nr,'nc) abstraction \<Rightarrow> 
  (('ni Interp_inst) * (('nr, 'nc) Interp) ) \<Rightarrow> (('ni,'nr,'nc) abox_impl) \<Rightarrow> bool"
   where
     "satisfies_abox_impl abstr i ai = (\<forall> f \<in> abstr ai. satisfiable_fact i f)"

definition satisfiable_abox_impl :: 
  "('ni,'nr,'nc) abstraction \<Rightarrow> (('ni,'nr,'nc) abox_impl) \<Rightarrow> bool"
   where
     "satisfiable_abox_impl abstr ai = (\<exists> i. satisfies_abox_impl abstr i ai)"

constdefs
  sound_impl :: "('ni,'nr,'nc) abstraction \<Rightarrow> ('ni,'nr,'nc) rule_impl \<Rightarrow> bool"
  "sound_impl abstr r_impl == 
  \<forall> ai1 ai2. ai2 \<in> set (r_impl ai1) \<longrightarrow> 
  satisfiable_abox_impl abstr ai2 \<longrightarrow> satisfiable_abox_impl abstr ai1"

lemma sound_rule_impl_reduction:
  "sound_rule_impl abstr r r_impl \<Longrightarrow> sound r \<Longrightarrow> sound_impl abstr r_impl"
  apply (clarsimp simp add: sound_rule_impl_def sound_def sound_impl_def)
  apply (simp add: satisfiable_abox_impl_def)
  apply (clarsimp simp add: satisfiable_abox_def)
  apply (clarsimp simp add: satisfies_abox_impl_def)
  apply fastsimp
  done

constdefs
  cmplt_impl :: "('ni,'nr,'nc) abstraction \<Rightarrow> ('ni,'nr,'nc) rule_impl \<Rightarrow> bool"
  "cmplt_impl abstr r_impl == 
  \<forall> ai1. satisfiable_abox_impl abstr ai1 \<longrightarrow>
  (\<exists> ai2. ai2 \<in> set (r_impl ai1))
  \<longrightarrow> (\<exists> ai2. ai2 \<in> set (r_impl ai1) \<and> satisfiable_abox_impl abstr ai2)"

lemma satisfiable_abox_impl_abstr: 
  "satisfiable_abox_impl abstr ai \<Longrightarrow> satisfiable_abox (abstr ai)"
by (fastsimp simp add: 
  satisfiable_abox_def satisfiable_abox_impl_def satisfies_abox_impl_def)

lemma satisfiable_abox_abstr_impl:
  "satisfiable_abox (abstr ai) \<Longrightarrow> satisfiable_abox_impl abstr ai"
by (fastsimp simp add: 
  satisfiable_abox_def satisfiable_abox_impl_def satisfies_abox_impl_def)


lemma complete_rule_impl_reduction:
  "complete_rule_impl abstr r r_impl \<Longrightarrow> cmplt r 
  \<Longrightarrow> sound_rule_impl abstr r r_impl
  \<Longrightarrow> cmplt_impl abstr r_impl"
  apply (clarsimp simp add: complete_rule_impl_def cmplt_def cmplt_impl_def)
  apply (drule_tac x="abstr ai1" in spec, drule mp) 
  apply (erule satisfiable_abox_impl_abstr)
  apply (subgoal_tac "r (abstr ai1) (abstr ai2)") 
     prefer 2 apply (clarsimp simp add: sound_rule_impl_def)
  apply (fastsimp intro: satisfiable_abox_abstr_impl)
done


(*** Rules implementation ***)

consts
  split_appcond  :: 
  "(('ni, 'nr, 'nc) appcond) 
  \<Rightarrow> ('ni, 'nr, 'nc) abox_impl
  \<Rightarrow> ('ni, 'nr, 'nc) abox_impl
  \<Rightarrow> ('ni, 'nr, 'nc) abox_impl
  \<Rightarrow> ((('ni, 'nr, 'nc) abox_impl * ('ni, 'nr, 'nc) fact * ('ni, 'nr, 'nc) abox_impl)list)" 
primrec
  "split_appcond appc prefix [] ab = []"
  "split_appcond appc prefix (ft#suffix) ab = 
    (if (appc ab ft)
    then (prefix, ft, suffix) #
         (split_appcond appc (prefix @ [ft]) suffix ab)    
    else (split_appcond appc (prefix @ [ft]) suffix ab))"


lemma split_appcond_invariant [rule_format]:
  "\<forall> prefix ab. 
  (prefix @ suffix = ab \<longrightarrow>
  (\<forall> (p, f, s) \<in> set (split_appcond appc prefix suffix ab).
  (p @ [f] @ s = ab \<and> appc ab f)))"
  apply (induct suffix)
  apply simp
  apply (clarsimp simp add: split_def)
  apply (rename_tac a suffix prefix p f s)
  apply (drule_tac x="prefix@[a]" in spec)
  apply fastsimp
  done

lemma split_appcond_invariant2 [rule_format]:
  "\<forall> prefix ab. 
  (ab = prefix @ suffix \<longrightarrow>
  (\<forall> p f s. 
  (p, f, s) \<in> set (split_appcond appc prefix suffix ab) \<longrightarrow> 
  (p @ [f] @ s = ab \<and> appc ab f)))"
  apply (induct suffix)
  apply simp
  apply (clarsimp simp add: split_def)
  apply (rename_tac a suffix prefix p f s)
  apply (drule_tac x="prefix@[a]" in spec)
  apply (drule_tac x=p in spec)
  apply (drule_tac x=f in spec)
  apply (drule_tac x=s in spec)
  apply simp
  done


lemma split_appcond_invariant3:
  "\<lbrakk>(p, f, s) \<in> set (split_appcond appc prefix suffix ab);
      ab = prefix @ suffix \<rbrakk>
    \<Longrightarrow> p @ [f] @ s = ab \<and> appc ab f"
  apply (rule split_appcond_invariant2) apply assumption+
  done


(**************************************************************)
(*--------------------- rules application --------------------*)
(**************************************************************)

fun apply_srule :: 
  "('ni, 'nr, 'nc) srule \<Rightarrow> ('ni, 'nr, 'nc) rule_impl" 
  where 
  "apply_srule (Rule(appc, act)) ab_i =
  concat (map act (split_appcond appc [] ab_i ab_i))"
(*
constdefs "AB3_list== [
  Inst ''x'' (AllC (AtomR ''r'') (AtomC ''B'')) ,
  Inst ''x'' (AllC (AtomR ''r2'') (AtomC ''C'')) ,
  Rel (AtomR ''r'') ''x''''y'',
  Rel (AtomR ''r'') ''x''''z'',
  Rel (AtomR ''r2'') ''x''''z'',
  Inst ''y'' (OrC (AtomC ''C'') (AtomC ''D''))]"


 normal_form " apply_srule  all_rule AB3_list"
*)

(***********************************)

fun is_x_c_inst :: "'ni \<Rightarrow> ('nr, 'nc) concept \<Rightarrow> ('ni, 'nr, 'nc) fact\<Rightarrow> bool"
  where 
  "is_x_c_inst x c f =  (f = Inst x c)"


lemma list_ex_is_x_c_inst:
  "(list_ex (is_x_c_inst x c) xs) =  ((Inst x c) \<in> set xs)"
  by (induct xs) auto

(***********************************************)
(***********************************************)
(***********************************************)
(*************      And rule     ***************)
(***********************************************)
(***********************************************)

fun appcond_and :: "('ni, 'nr, 'nc) appcond"
  where
    "appcond_and Ab_i (Inst x (AndC c1 c2)) = 
      ((\<not> (list_ex (is_x_c_inst x c1) Ab_i )) \<or> \<not> (list_ex (is_x_c_inst x c2) Ab_i ))"
    |"appcond_and Ab_i  _  = False"

lemma appcond_and_rewr:
  "appcond_and Ab_i fct = 
(\<exists> x c1 c2. (fct = (Inst x (AndC c1 c2)) \<and> ((\<not> (list_ex (is_x_c_inst x c1) Ab_i )) \<or> \<not> (list_ex (is_x_c_inst x c2) Ab_i ))))"
  apply (case_tac fct)
  apply (case_tac concept)
  apply simp_all
  done

lemma and_applicable_appcond_and:
  "f \<in> set ab \<Longrightarrow> 
  and_applicable (set ab) f = appcond_and ab f"
  by (simp add: and_applicable_def appcond_and_rewr)
     (fastsimp simp add: list_ex_is_x_c_inst)


fun action_and :: "('ni, 'nr, 'nc) action"
where
  "action_and (prefix, (Inst x (AndC c1 c2)), suffix) = 
    [[(Inst x c1), (Inst x c2)] @ prefix @ [Inst x (AndC c1 c2)] @ suffix]"
  | "action_and _  = []"


constdefs and_srule ::"('ni, 'nr, 'nc) srule" 
  "and_srule == Rule (appcond_and, action_and)"

constdefs and_rule ::"('ni, 'nr, 'nc) rule_impl" 
  "and_rule \<equiv> apply_srule and_srule"

(***********************************************)
(***********************************************)
(***********************************************)
(*************      Or rule     ****************)
(***********************************************)
(***********************************************)

fun appcond_or :: "('ni, 'nr, 'nc) appcond"
  where
    "appcond_or Ab_i (Inst x (OrC c1 c2)) = 
      ((\<not> (list_ex (is_x_c_inst x c1) Ab_i )) \<and> \<not> (list_ex (is_x_c_inst x c2) Ab_i ))"
    |"appcond_or Ab_i  _  = False"

lemma appcond_or_rewr:
  "appcond_or  Ab_i fct = 
(\<exists> x c1 c2. (fct = (Inst x (OrC c1 c2)) \<and> ((\<not> (list_ex (is_x_c_inst x c1) Ab_i )) \<and> \<not> (list_ex (is_x_c_inst x c2) Ab_i ))))"
apply (case_tac fct)
apply (case_tac concept)
apply simp_all
done

(* for this rule there is tow action !!! left and right *)

fun action_or_left:: "('ni, 'nr, 'nc) action"
where
  "action_or_left (prefix, (Inst x (OrC c1 c2)), suffix) = 
    [[(Inst x c1)] @ prefix @ [Inst x (OrC c1 c2)] @ suffix]"
  | "action_or_left _  = []"

fun action_or_right:: "('ni, 'nr, 'nc) action"
where
  "action_or_right (prefix, (Inst x (OrC c1 c2)), suffix) = 
    [[(Inst x c2)] @ prefix @ [Inst x (OrC c1 c2)] @ suffix]"
  | "action_or_right _  = []"

fun action_or:: "('ni, 'nr, 'nc) action"
where
  "action_or (prefix, (Inst x (OrC c1 c2)), suffix) = 
    [[(Inst x c1)] @ prefix @ [Inst x (OrC c1 c2)] @ suffix,
     [(Inst x c2)] @ prefix @ [Inst x (OrC c1 c2)] @ suffix]"
  | "action_or  _  = []"

(**** we can define tow rule **)

constdefs or_srule_left ::"('ni, 'nr, 'nc) srule" 
  "or_srule_left == Rule (appcond_or , action_or_left)"

constdefs or_rule_left ::"('ni, 'nr, 'nc) rule_impl" 
  "or_rule_left == apply_srule or_srule_left"

constdefs or_srule_right ::"('ni, 'nr, 'nc) srule" 
  "or_srule_right == Rule (appcond_or , action_or_right)"

constdefs or_rule_right ::"('ni, 'nr, 'nc) rule_impl" 
  "or_rule_right == apply_srule or_srule_right"

(**** using one rule ******)
constdefs or_srule ::"('ni, 'nr, 'nc) srule" 
  "or_srule == Rule (appcond_or , action_or)"

constdefs or_rule ::"('ni, 'nr, 'nc) rule_impl" 
  "or_rule == apply_srule or_srule"

(***********************************************)
(***********************************************)
(***********************************************)
(*************      All rule     **************)
(***********************************************)
(***********************************************)

fun is_x_r_rel :: "'ni \<Rightarrow> 'ni \<Rightarrow> ('nr) role \<Rightarrow> ('ni, 'nr, 'nc) fact\<Rightarrow> bool"
  where 
  "is_x_r_rel x  y r  f =  (f = Rel r x y)"

lemma list_ex_is_x_r_rel:
  "(list_ex (is_x_r_rel x y r) xs) =  ( Rel r x y  \<in> set xs)"
  by (induct xs) auto

fun is_related_all ::" 'ni \<Rightarrow> 'nr role \<Rightarrow> ('nr, 'nc) concept \<Rightarrow> ('ni, 'nr, 'nc) abox_impl \<Rightarrow> ('ni, 'nr, 'nc) fact \<Rightarrow> bool "
  where
  "is_related_all x r c Ab_i (Rel r' x' y) = ((x = x'  \<and> r = r') \<and> (\<not>  (list_ex  (is_x_c_inst y c) Ab_i)))"
 | "is_related_all x r c Ab_i _ = False "

fun is_related_all_test ::" 'ni \<Rightarrow> 'nr role \<Rightarrow> ('nr, 'nc) concept \<Rightarrow> ('ni, 'nr, 'nc) abox_impl \<Rightarrow> ('ni, 'nr, 'nc) fact \<Rightarrow> bool "
  where
  "is_related_all_test x r c Ab_i (Rel r' x' y) = ((x = x'  \<and> r = r') \<and> (list_ex (is_x_r_rel  x  y r) Ab_i) \<and> (\<not>  (list_ex  (is_x_c_inst y c) Ab_i)))"
 | "is_related_all_test  x r c Ab_i _ = False "

lemma is_related_all_test_rew:
  "is_related_all_test x r c Ab_i f = (\<exists> y. f = (Rel r x y) \<and> (list_ex (is_x_r_rel  x  y r) Ab_i) \<and>(\<not>  (list_ex  (is_x_c_inst y c) Ab_i)))"
  apply  (case_tac f)
  apply (fastsimp simp add: list_ex_is_x_c_inst list_ex_is_x_r_rel)+
  done

lemma is_related_all_rew:
  "is_related_all x r c Ab_i f = (\<exists> y. f = (Rel r x y) \<and> (\<not>  (list_ex  (is_x_c_inst y c) Ab_i)))"
  apply  (case_tac f)
  apply (fastsimp simp add: list_ex_is_x_c_inst)+
  done


lemma is_related_all_rew2 :
  "is_related_all x r c Ab_i f = (\<exists> y. (f = (Rel r x y) \<and> (Inst y c) \<notin> set(Ab_i))) "
  by (clarsimp simp add: is_related_all_rew list_ex_is_x_c_inst )


lemma is_related_all_test_rew2 :
  "is_related_all_test x r c Ab_i f = (\<exists> y. (f = (Rel r x y) \<and> f \<in> set(Ab_i) \<and> (Inst y c) \<notin> set(Ab_i))) "
  by (fastsimp simp add: is_related_all_test_rew list_ex_is_x_c_inst list_ex_is_x_r_rel)


lemma list_ex_is_related_all :
" list_ex (is_related_all_test x r c Ab_i) Ab_i = (\<exists> y.( (Rel r x y) \<in> set Ab_i \<and> (Inst y c) \<notin> set(Ab_i)))"

by (fastsimp simp add : list_ex_iff is_related_all_test_rew2 )

fun appcond_all :: "('ni, 'nr, 'nc) appcond"
  where
    "appcond_all Ab_i (Inst x (AllC r c)) =list_ex (is_related_all_test x r c Ab_i ) Ab_i"
    |"appcond_all Ab_i  _  = False"

(* export_code appcond_all in OCaml file "appcond_all.ml" *)

lemma appcond_all_rewr:
  "appcond_all Ab_i fct = 
  (\<exists> x  r c . (fct = (Inst x (AllC r c)) \<and> list_ex (is_related_all_test x r c Ab_i ) Ab_i))"
  apply (case_tac fct)
  apply (case_tac concept)
  apply simp_all
  done


    (* --------------------------------------------------  *)

consts filter_select :: "('a \<Rightarrow> 'b option) \<Rightarrow> 'a list \<Rightarrow> 'b list"
primrec
  "filter_select sel [] = []"
  "filter_select sel (x # xs) = 
  (case sel x of
  Some y \<Rightarrow> y # filter_select sel xs
  | None \<Rightarrow> filter_select sel xs)"

fun sel_rel_y :: "'nr role \<Rightarrow> 'ni \<Rightarrow> ('ni, 'nr, 'nc) fact \<Rightarrow> 'ni option"
where 
  "sel_rel_y r x (Rel r' x' y ) = (if ((r = r') \<and> (x = x')) then Some y else None)"
| "sel_rel_y r x _ = None"


fun sel_rel_y2 :: "'nr role \<Rightarrow> 'ni \<Rightarrow> ('ni, 'nr, 'nc) fact \<Rightarrow> 'ni option"
where 
  "sel_rel_y2 r x  = (\<lambda> f.
    (case f of 
    (Rel r' x' y ) \<Rightarrow> (if ((r = r') \<and> (x = x')) then Some y else None)
    | _ \<Rightarrow> None))"

lemma "sel_rel_y r x f = sel_rel_y2 r x f"
by (auto split add: fact.splits)

fun sel_inst_y :: "('nr,'nc)concept \<Rightarrow> ('ni, 'nr, 'nc) fact \<Rightarrow> 'ni option"
where 
  "sel_inst_y c (Inst y c') = (if (c = c') then Some y else None)"
| "sel_inst_y c _ = None"

lemma sel_rel_y_Some: "(sel_rel_y r x f = Some y) = (f = (Rel r x y))"
by (case_tac f) clarsimp+

lemma sel_inst_y_Some: "(sel_inst_y c f = Some y) = (f = (Inst y c))"
by (case_tac f) clarsimp+


lemma set_filter_select:
  "set (filter_select sel xs) = {y. \<exists> f \<in> set xs. sel f = Some y}"
  apply (induct xs)
  apply simp
  apply (fastsimp simp add:  insert_compr Collect_def mem_def
    split add: option.splits)
  done

lemma filter_select_set_sel_rel_y:
  "set (filter_select (sel_rel_y r x) xs) = {y. (Rel r x y) \<in> set xs}"
  by (simp add: set_filter_select sel_rel_y_Some)

lemma filter_select_set_sel_inst_y:
  "set (filter_select (sel_inst_y c) xs) = {y. (Inst y c) \<in> set xs}"
  by (simp add: set_filter_select sel_inst_y_Some)


consts 
  list_diff :: "'a list \<Rightarrow> 'a list \<Rightarrow> 'a list"
primrec
  "list_diff [] ys = []"
  "list_diff (x#xs) ys = (if (x mem ys) then list_diff xs ys else x # (list_diff xs ys))"

lemma set_list_diff [simp]: "set (list_diff xs ys) = (set xs) - (set ys)"
  apply (induct xs) 
  apply simp
  apply (clarsimp simp add: mem_iff)
  apply blast
  done

lemma "set (list_diff (filter_select (sel_rel_y r x) xs) (filter_select (sel_inst_y c) xs))
  = {y. (Rel r x y)  \<in> set xs \<and> \<not> (Inst y c) \<in> set xs}"
  by (fastsimp simp add: filter_select_set_sel_rel_y filter_select_set_sel_inst_y)

    (* An attempt to automate things further. not really convincing.
    constdefs test_of_sel :: "('a \<Rightarrow> 'b option) \<Rightarrow> 'a \<Rightarrow> 'b \<Rightarrow> bool"
    "test_of_sel sel a == \<lambda> y. (case sel a of Some y' \<Rightarrow> y = y' | None \<Rightarrow> False)"
    
    lemma filter_select_test_of_sel:
    "set (filter_select sel xs) = {y. \<exists> f \<in> set xs. test_of_sel sel f y}"
    apply (induct xs)
    apply simp
    apply (fastsimp simp add: 
    test_of_sel_def insert_compr Collect_def mem_def expand_fun_eq
    split add: option.splits)
    done
    
    lemma "test_of_sel (sel_rel_y r x) f y = (f = (Rel r x y))"
    apply (case_tac f) 
    apply (clarsimp simp add: test_of_sel_def sel_rel_y_Some)+
    apply fastsimp+
    done

    lemma "test_of_sel (sel_rel_y r x) f  = (\<lambda> y. (f = (Rel r x y)))"
    by (case_tac f) (auto simp add: test_of_sel_def expand_fun_eq )
    
    lemma test_of_sel_sel_rel_y2:
    "test_of_sel (sel_rel_y2 r x)  = (\<lambda> f y. (f = (Rel r x y)))"
    by (auto simp add: test_of_sel_def expand_fun_eq  split add: fact.splits)
    
    *)

    (* --------------------------------------------------  *)


    (* la regle all peut s'appliquer sur un fais et produit plusieur fais*)
    (* le nombre des fais ajoute est generalement on fonction des rxy qui trouve dans l'abox *)
    (*** costruction de la liste de y:c telque xry dans labox_imp et y:c \<notin> AB*)


fun my_trans ::  "('nr, 'nc) concept \<Rightarrow> ('ni, 'nr, 'nc) fact \<Rightarrow>('ni, 'nr, 'nc) fact"
 where
  " my_trans c (Rel r x y) = Inst y c"


lemma  [simp] : " ( (Rel r x y ) \<in> (set A)) \<longrightarrow> ((Inst y c) \<in>  set (map (my_trans c) A)) "
  apply (induct A)
  apply fastsimp+
  done

term "filter (is_related_all_test x r c Ab_i)"

lemma [simp] :
  "Inst x1 c2 \<notin> set ( filter (is_related_all_test x r c Ab_i) Ab_i)"
  apply( clarsimp simp add: is_related_all_test_rew2)
  done

lemma [simp]:
  "(Inst y c \<notin> set Ab_i \<and> Rel r x y \<in> (set  Ab_i)) =  (Rel r x y \<in> set ( filter (is_related_all_test x r c Ab_i) Ab_i))"
  by  ( fastsimp simp add: is_related_all_test_rew2)

lemma my_rule:
  "(Inst y c \<notin> set Ab_i \<and> Rel r x y \<in> (set  Ab_i)) =  (Inst y c \<in> set (map (my_trans c)( filter (is_related_all_test x r c Ab_i) Ab_i)))"
  apply (induct Ab_i)
  apply   ( clarsimp simp add: is_related_all_test_rew2)+ apply auto
  done
    (*lemma my_rule2:
    "  (Inst y c \<in> set (map (my_trans c)( filter (is_related_all_test x r c Ab_i) Ab_i))) = (Inst y c \<notin> set Ab_i \<and> Rel r x y \<in> (set  Ab_i))  "
    apply (induct Ab_i)
    apply   ( clarsimp simp add: is_related_all_test_rew2)+ apply auto
    done
    *)
constdefs
  list_distrib ::  " 'a list \<Rightarrow> 'a list \<Rightarrow> 'a list list "
  "list_distrib xs ys == map (\<lambda> x. (x# ys)) xs"

lemma set_list_distrib [simp]: 
  "set (list_distrib xs ys) = (\<lambda>x. x # ys) ` set xs"
  by (simp add: list_distrib_def)

normal_form "list_distrib [1::nat, 2] [0,0]"
fun action_all :: "('ni, 'nr, 'nc) action"
  where
  "action_all (prefix, (Inst x (AllC r c)) , suffix) = 
  ( 
  let ab_orig = (prefix @ [Inst x (AllC r c)] @ suffix) in
  let related = ( filter (is_related_all_test x r c ab_orig) ab_orig) in
  let new_fact = (map (my_trans c) related) in
  list_distrib new_fact ab_orig)"
  | "action_all  _  = []"


constdefs all_srule ::"('ni, 'nr, 'nc) srule" 
  "all_srule == Rule (appcond_all, action_all)"
constdefs all_rule ::"('ni, 'nr, 'nc) rule_impl" 
  "all_rule == apply_srule all_srule"


  (***********************************************)
  (***********************************************)
  (***********************************************)
  (*************      some rule     **************)
  (***********************************************)
  (***********************************************)



fun is_related_some_neg ::" 'ni \<Rightarrow> 'nr role \<Rightarrow> ('nr, 'nc) concept \<Rightarrow> ('ni, 'nr, 'nc) abox_impl \<Rightarrow> ('ni, 'nr, 'nc) fact \<Rightarrow> bool "
  where
  "is_related_some_neg x r c Ab_i (Rel r' x' y) = ((x = x'  \<and> r = r') \<and> (list_ex (is_x_r_rel  x  y r) Ab_i) \<and> ( (list_ex  (is_x_c_inst y c) Ab_i)))"
  | "is_related_some_neg  x r c Ab_i _ = False "


lemma is_related_all_some_neg:
  "is_related_some_neg  x r c Ab_i f = (\<exists> y. f = (Rel r x y) \<and> (list_ex (is_x_r_rel  x  y r) Ab_i) \<and>( (list_ex  (is_x_c_inst y c) Ab_i)))"
  apply  (case_tac f)
  apply (fastsimp simp add: list_ex_is_x_c_inst list_ex_is_x_r_rel)+
  done

lemma not_list_ex_is_related_some_neg:
  "(\<not> list_ex ( is_related_some_neg  x r c Ab_i) Ab_i)
  = (\<forall>  y. \<not> ( (Rel r x y) \<in> set Ab_i \<and> (Inst y c) \<in>  set(Ab_i))) "
  by (fastsimp simp add : list_ex_iff is_related_all_some_neg )


fun appcond_some :: "('ni, 'nr, 'nc) appcond"
  where
  "appcond_some Ab_i (Inst x (SomeC r c ))  = 
  (\<not> list_ex ( is_related_some_neg  x r c Ab_i) Ab_i) "
  |"appcond_some Ab_i  _  = False"

lemma appcond_some_rewr:
  "appcond_some Ab_i fct = 
  (\<exists> x r c. (fct = (Inst x (SomeC r c ))) \<and>(\<not> list_ex ( is_related_some_neg  x r c Ab_i) Ab_i))"
  apply (case_tac fct)
  apply (case_tac concept)
  apply simp_all
  done


fun list_ni_abox_imp ::"('ni, 'nr, 'nc) fact list \<Rightarrow> 'ni list"
  where 
   "list_ni_abox_imp [] = []"
  | "list_ni_abox_imp (xl#xs) = (case xl of 
  Rel r x y \<Rightarrow>  list_union [x] (list_union [y] (list_ni_abox_imp xs) )
  | Inst x c \<Rightarrow>  list_union [x] (list_ni_abox_imp xs))"

  (*** pour ajouter un element il est necessaire de construire cet element *)


lemma occurs_ni_in_abox_list_ni_abox_imp:
  "occurs_ni_in_abox x (set ab) =  (x \<in> set (list_ni_abox_imp ab))"
  apply (induct ab)
  apply simp+
  apply (fastsimp split add: fact.splits)
  done
 
constdefs gen_not_occurs_ni_in_abox :: 
  "('ni::alloc, 'nr, 'nc) abox_impl \<Rightarrow> 'ni"
  "gen_not_occurs_ni_in_abox ab \<equiv> (new_var (list_ni_abox_imp ab))"


lemma foo:
  "((gen_not_occurs_ni_in_abox ab) \<in> set (list_ni_abox_imp ab)) = False"
  by (simp add: gen_not_occurs_ni_in_abox_def new_var_gen)
 
lemma tt:
  "(x \<notin>  set (list_ni_abox_imp ab)) \<longrightarrow>  ((Inst x c) \<notin> set ab)"
  apply (induct ab)
  apply simp
  apply (clarsimp split add: fact.splits)
  done

lemma tt2:
  "(x \<notin>  set (list_ni_abox_imp ab)) \<longrightarrow>  ((Rel r x y) \<notin> set ab)"
  apply (induct ab)
  apply simp
  apply (clarsimp split add: fact.splits)
  done

lemma tt3:
  "(y \<notin>  set (list_ni_abox_imp ab)) \<longrightarrow>  ((Rel r x y) \<notin> set ab)"
  apply (induct ab)
  apply simp
  apply (clarsimp split add: fact.splits)
  done

lemma ttt:
  "((Inst x c) \<in>  set ab) \<longrightarrow> (x \<in>  set (list_ni_abox_imp ab))"
  apply (induct ab)
  apply simp
  apply (clarsimp split add: fact.splits)
  done

lemma t2: "(new_var xs) = g  \<longrightarrow> (g \<notin> (set xs)) "
  apply auto
  apply (simp add: new_var_gen)
  done

lemma inst_to :
  "Inst (new_var (list_ni_abox_imp ab)) c \<notin>  set ab"
  apply (subgoal_tac "(new_var (list_ni_abox_imp ab))  \<notin> set (list_ni_abox_imp ab)")
  apply (simp add : tt)
  apply  (clarsimp simp add: new_var_gen)
  done

lemma rel_to :
  "Rel r x (new_var (list_ni_abox_imp ab))  \<notin>  set ab"
  apply (subgoal_tac "(new_var (list_ni_abox_imp ab))  \<notin> set (list_ni_abox_imp ab)")
  apply (simp add : tt3)
  apply  (clarsimp simp add: new_var_gen)
  done

lemma rel1_to :
  "Rel r (new_var (list_ni_abox_imp ab)) y  \<notin>  set ab"
  apply (subgoal_tac "(new_var (list_ni_abox_imp ab))  \<notin> set (list_ni_abox_imp ab)")
  apply (simp add : tt2)
  apply  (clarsimp simp add: new_var_gen)
  done

lemma spec_gen :
  "(ab = set abi) \<Longrightarrow> not_occurs_ni_in_abox (gen_not_occurs_ni_in_abox abi) ab"
  apply simp
  apply (clarsimp simp add:  gen_not_occurs_ni_in_abox_def new_var_gen)
  apply (case_tac f)
  apply (clarsimp simp add : inst_to)
  apply auto
  apply (clarsimp simp add:  rel1_to)
  apply (clarsimp simp add:  rel_to)
  done


fun action_some :: "('ni::alloc, 'nr, 'nc) action"
  where
  "action_some (prefix, (Inst x (SomeC r c)), suffix) = 
  (let ab_org = (prefix @ [Inst x (SomeC r c)] @ suffix) in
  let genvar = gen_not_occurs_ni_in_abox ab_org in
  [[ Inst genvar c, Rel r x genvar] @ ab_org])"
  | "action_some  _  = []"


constdefs some_srule ::"('ni::alloc, 'nr, 'nc) srule" 
  "some_srule == Rule (appcond_some, action_some)"

constdefs some_rule ::"('ni::alloc, 'nr, 'nc) rule_impl" 
  "some_rule == apply_srule some_srule"


  (*********************************************************)
  (*                                                       *)
  (*                                                       *)
  (* -------  implementation of ALC  Resoner   ------------*)
  (*                                                       *)
  (*                                                       *)
  (*********************************************************)

fun empty_rule_impl :: "('ni,'nr,'nc) rule_impl"
  where "empty_rule_impl a = []"

fun compose_rule_appl ::
  "('ni,'nr,'nc) rule_impl \<Rightarrow> ('ni,'nr,'nc) rule_impl \<Rightarrow> ('ni,'nr,'nc) rule_impl"
  where "compose_rule_appl r1 r2 = (\<lambda> ab. concat (map r2 (r1 ab)))"

fun disj_rule_impl ::
  "('ni,'nr,'nc) rule_impl \<Rightarrow> ('ni,'nr,'nc) rule_impl \<Rightarrow> ('ni,'nr,'nc) rule_impl"
  where "disj_rule_impl r1 r2 = (\<lambda> ab. (list_union (r1 ab) (r2 ab)))"

fun  disj_rule_list_impl :: 
  "('ni,'nr,'nc) rule_impl list  \<Rightarrow> ('ni,'nr,'nc) rule_impl" 
  where 
  "disj_rule_list_impl [] = empty_rule_impl"
  |"disj_rule_list_impl (r#rs) = (disj_rule_impl r (disj_rule_list_impl rs))"


constdefs list_alc_rules_impl ::" ('ni::alloc, 'nr, 'nc) rule_impl list "
 "list_alc_rules_impl == 
  [and_rule, or_rule, all_rule, some_rule]"

  (* just use one or_rule instead of or_rule_left, or_rule_right
  "list_alc_rules_impl == 
  [and_rule, or_rule_left, or_rule_right, all_rule, some_rule]"
  *)

definition  alc_rule_impl :: "('ni::alloc,'nr,'nc) rule_impl"
  where 
  "alc_rule_impl = disj_rule_list_impl list_alc_rules_impl"


lemma sound_rule_impl_empty_rule [simp]:
  "sound_rule_impl abstr empty_rule empty_rule_impl"
  by (simp add: sound_rule_impl_def)

lemma sound_rule_impl_disj_rule [simp]:
  "sound_rule_impl abstr r1 r1i \<Longrightarrow>
  sound_rule_impl abstr r2 r2i \<Longrightarrow>
  sound_rule_impl abstr (disj_rule r1 r2) (disj_rule_impl r1i r2i)"
  by (simp add: sound_rule_impl_def)


lemma sound_rule_impl_disj_rule_list [simp]:
  "list_all2 (sound_rule_impl abstr) rs ris \<Longrightarrow>
  sound_rule_impl abstr (disj_rule_list rs) (disj_rule_list_impl ris)"
  apply (clarsimp simp add: list_all2_def)
  apply (induct rule: list_induct2)
  apply simp
  apply (simp only: disj_rule_list.simps disj_rule_list_impl.simps)
  apply (rule sound_rule_impl_disj_rule)
  apply simp+
  done


fun is_reducible_abox ::
  "('ni, 'nr, 'nc) rule_impl \<Rightarrow> ('ni, 'nr, 'nc) abox_impl \<Rightarrow> bool"
  where
  "is_reducible_abox rule ab = (rule ab \<noteq> [])"

fun is_reducible_tableau ::
  "('ni, 'nr, 'nc) rule_impl \<Rightarrow> ('ni, 'nr, 'nc) tableau \<Rightarrow> bool"
  where
  "is_reducible_tableau rule = list_ex (is_reducible_abox rule)"

fun apply_rule_tableau ::
  "('ni, 'nr, 'nc) rule_impl \<Rightarrow> ('ni, 'nr, 'nc) tableau \<Rightarrow> ('ni, 'nr, 'nc) tableau"
  where
  "apply_rule_tableau rule tab = concat (map rule tab)"

  (* really useful? *)
constdefs  is_reducible_alc_rule ::
  "('ni::alloc, 'nr, 'nc) abox_impl \<Rightarrow> bool"
  "is_reducible_alc_rule  == is_reducible_abox alc_rule_impl"



lemma c_not_eq_and_c :
  " c1 \<noteq> AndC c1 c2"
  apply (induct c1)
  apply fastsimp+
  done

lemma  not_andrule_not_reducible :
  "(\<forall> a2. \<not> (Andrule (set a1) a2)) \<longrightarrow> \<not> (is_reducible_abox and_rule a1)"
  apply (clarsimp simp add: and_rule_def and_srule_def)
  apply (drule split_appcond_invariant3)
  apply simp
  apply (clarsimp simp add: appcond_and_rewr list_ex_is_x_c_inst)
  apply (subgoal_tac" c1 \<noteq>  AndC c1 c2" )
  apply (clarsimp simp add: andrule_simp)
  apply auto
  apply (clarsimp simp add: c_not_eq_and_c)+
sorry                           (* repair with new def of and_applicable *)

    (*
    normal_form  
    "is_reducible_abox 
    [ Inst (1::nat) (OrC (AtomC ''A'') (AtomC ''B'')),
    Inst 1 (AllC (AtomR ''r'') (AtomC ''A'')),
    Rel (AtomR ''r'') 2 2 ] 
    all_rule "
    
    (*first stratigie apply rules for the first abox.
    and in the  ordre *)
    
    
    apply_srules :: "('ni, 'nr, 'nc) srule list \<Rightarrow>('ni, 'nr, 'nc) tableau \<Rightarrow> ('ni, 'nr, 'nc) tableau"
    
    *)





    (*********************************************************)
    (*                                                       *)
    (*                                                       *)
    (* ---------            Soundness        ----------------*)
    (*                                                       *)
    (*                                                       *)
    (*********************************************************)



  (* it would be nice to exploit the 
       lemma and_applicable_appcond_and
       in the following proof ... *)
lemma   sound_rule_impl_and [simp]:
  "sound_rule_impl set Andrule and_rule"
  apply (clarsimp simp add : sound_rule_impl_def)
  apply (clarsimp simp add: and_rule_def and_srule_def)
  apply (drule split_appcond_invariant3)  apply simp
  apply (simp add: andrule_simp)
  apply (clarsimp simp add: appcond_and_rewr)
  apply (simp add: and_applicable_def)
  apply (fastsimp simp add: list_ex_is_x_c_inst)+
  done


lemma   sound_rule_impl_or_left [simp]:
  "sound_rule_impl set Orruleleft or_rule_left"
  apply (clarsimp simp add : sound_rule_impl_def)
  apply (clarsimp simp add: or_rule_left_def or_srule_left_def)
  apply (drule split_appcond_invariant3)
  apply simp
  apply (clarsimp simp add: appcond_or_rewr)
  apply (rule mk_orruleleft) apply fastsimp
  apply (fastsimp simp add: list_ex_is_x_c_inst)+
  done

lemma   sound_rule_impl_or_right [simp]:
  "sound_rule_impl set Orruleright or_rule_right "
  apply (clarsimp simp add : sound_rule_impl_def)
  apply (clarsimp simp add: or_rule_right_def or_srule_right_def)
  apply (drule split_appcond_invariant3)
  apply simp
  apply (clarsimp simp add: appcond_or_rewr)
  apply (rule mk_orruleright) apply fastsimp
  apply (fastsimp simp add: list_ex_is_x_c_inst)+
  done

lemma   sound_rule_impl_all [simp]:
  "sound_rule_impl set Allrule all_rule "
  apply (clarsimp simp add : sound_rule_impl_def all_rule_def all_srule_def)
  apply (drule split_appcond_invariant3) 
  apply simp
  apply (clarsimp simp add: appcond_all_rewr Let_def image_def list_ex_is_related_all)
  apply (subgoal_tac "is_related_all_test x r c (a @ Inst x (AllC r c) # b) (Rel r x y) ")
  apply (clarsimp simp add: is_related_all_test_rew list_ex_is_x_r_rel list_ex_is_x_c_inst) apply (elim disjE)
  apply (( clarsimp simp add :allrule_simp), blast)+ 
  apply (clarsimp simp add: is_related_all_test_rew list_ex_is_x_r_rel list_ex_is_x_c_inst)
  done

lemma   sound_rule_impl_some [simp]:
  "sound_rule_impl set Somerule some_rule"
  apply (clarsimp simp add : sound_rule_impl_def some_rule_def some_srule_def)
  apply (drule split_appcond_invariant3) 
  apply simp
  apply (clarsimp simp add: appcond_some_rewr Let_def image_def)
  apply (simp add: not_list_ex_is_related_some_neg)
  apply (rule mk_Somerule)
  apply fastsimp
  apply fastsimp
  defer
  apply blast
  apply (fastsimp intro: spec_gen)
done

  (**********************************)
lemma   sound_rule_impl_or [simp]:
  "sound_rule_impl set Orrule or_rule"
  apply (clarsimp simp add : sound_rule_impl_def)
  apply (clarsimp simp add: or_rule_def or_srule_def)
  apply (drule split_appcond_invariant3)
  apply simp
  apply (clarsimp simp add: appcond_or_rewr)
  apply (rule mk_orrule) apply fastsimp
  apply (fastsimp simp add: list_ex_is_x_c_inst)+
  done
 
    (* Alternative definition, using Somerule instead of Somerule3 *)

definition list_alc_rules_altern :: " (('ni,'nr,'nc) rule) list"
  where
  "list_alc_rules_altern =
  [ Andrule, Orrule,  Allrule, Somerule]"


definition  alc_rule_altern :: "('ni,'nr,'nc) rule"
  where 
  "alc_rule_altern = disj_rule_list list_alc_rules_altern"


lemma sound_rule_impl_alc_rule_impl [simp]:
  "sound_rule_impl set alc_rule_altern alc_rule_impl"
  by (simp add: alc_rule_altern_def alc_rule_impl_def 
    list_alc_rules_altern_def list_alc_rules_impl_def
    del: disj_rule_list.simps disj_rule_list_impl.simps)




    (*********************************************************)
    (*                                                       *)
    (*                                                       *)
    (* ---------        Completeness         ----------------*)
    (*                                                       *)
    (*                                                       *)
    (*********************************************************)
    (*--------------------------Completeness---------------------*)

    (* !!!!!! Needs some further considerations *)

    (*
    lemma   complete_implementation_and :
    "complete_rule_impl_set  set Andrule and_rule"
    apply (clarsimp simp add :complete_rule_impl_set_def)
    apply (clarsimp simp add: and_rule_def and_srule_def)  
    apply (clarsimp simp add:andrule_simp)
    
    apply (clarsimp simp add: appcond_and_rewr)
    apply (rule split_appcond_invariant3)

    apply(subgoal_tac "(split_appcond appcond_and [] ai ai). a = action_and x")
    apply blast
    apply (clarsimp simp add: appcond_and_rewr)
    apply (rule split_appcond_invariant3)  apply  

    *)

lemma split_appcond_invariantI_aux [rule_format]:
  "\<forall> prefix.
  (prefix @ p @ f#suffix = ab \<longrightarrow>
  appc ab f \<longrightarrow>
  (prefix @ p, f, suffix) \<in> set (split_appcond appc prefix (p @ f#suffix) ab))"
  by (induct p) clarsimp+


lemma split_appcond_invariantI: 
  "\<lbrakk>ab = prefix @ f # suffix; appc ab f\<rbrakk>
  \<Longrightarrow> (prefix, f, suffix)
  \<in> set (split_appcond appc [] ab ab)"
  apply (insert split_appcond_invariantI_aux [of "[]" prefix f suffix ab appc])
  apply clarsimp
  done

    (*
    lemma complete_rule_impl_and [simp]:
    "complete_rule_impl set Andrule and_rule"
    apply (clarsimp simp add : complete_rule_impl_def)
    apply (clarsimp simp add: andrule_simp)
    apply (rule_tac x="[(Inst x c1), (Inst x c2)] @ abi" in exI)
    apply (rule conjI)
    apply fastsimp

    apply simp
    apply (subgoal_tac "(Inst x (AndC c1 c2) \<in> set abi) = (\<exists>ys zs. abi = ys @ Inst x (AndC c1 c2) # zs)") prefer 2 apply (rule in_set_conv_decomp)
    apply simp
    apply (elim exE)
    apply (drule split_appcond_invariantI [where appc = appcond_and])
    apply (simp add: list_ex_is_x_c_inst)
    apply (simp add: and_rule_def and_srule_def)
    apply (rule bexI) prefer 2 apply assumption 
    apply simp
    apply (drule split_appcond_invariant3) apply simp+
    done
    
    
    lemma complete_rule_impl_abstr:
    "\<forall> abi. 
    (\<exists>  nfs pr sf. 
    (\<forall> ab'. abstr_rule (set abi) ab' \<longrightarrow> ab' = set (nfs @ abi)) \<and>
    abi = pr @ [f] @ sf \<and> appc abi f
    \<and> nfs @ abi \<in> set (act (pr, f, sf)))
    \<Longrightarrow> complete_rule_impl set abstr_rule (apply_srule (Rule(appc, act)))"
    apply (clarsimp simp add : complete_rule_impl_def)
    apply (drule_tac x=abi in spec)
    apply (elim exE conjE)
    apply (rule_tac x="nfs @ abi" in  exI)
    apply (rule conjI)
    prefer 2
    apply (drule split_appcond_invariantI [where appc = appc]) apply assumption
    apply (rule_tac x="(pr, f, sf)" in bexI) prefer 2 apply assumption 
    apply (drule split_appcond_invariant3) apply simp apply simp+
    done
    *)

lemma complete_rule_impl_abstr:
  "\<forall> abi ab'. abstr_rule (set abi) ab' \<longrightarrow> 
  (\<exists>  nfs pr f sf. ab' = set (nfs @ abi) \<and>
  abi = pr @ [f] @ sf \<and> appc abi f
  \<and> nfs @ abi \<in> set (act (pr, f, sf)))
  \<Longrightarrow> complete_rule_impl set abstr_rule (apply_srule (Rule(appc, act)))"
  apply (clarsimp simp add : complete_rule_impl_def)
  apply (drule_tac x=abi in spec)
  apply (drule_tac x=ab' in spec)
  apply simp
  apply (elim exE conjE)
  apply (rule_tac x="nfs @ abi" in  exI)
  apply (rule conjI)
  apply simp
  apply (drule split_appcond_invariantI [where appc = appc]) apply assumption
  apply (rule_tac x="(pr, f, sf)" in bexI) 
  apply (drule split_appcond_invariant3)
  apply simp+
  done


lemma complete_rule_impl_and [simp]:
  "complete_rule_impl set Andrule and_rule"
  apply (simp add: and_rule_def and_srule_def)
  apply (rule complete_rule_impl_abstr)
  apply (clarsimp simp add: andrule_simp)
  apply (rule_tac x="[(Inst x c1), (Inst x c2)]" in exI)
  apply (rule conjI) apply fastsimp

  apply (simp add: and_applicable_def) apply clarify
  apply (drule in_set_conv_decomp [THEN iffD1])
  apply (elim exE)
  apply (simp (no_asm_simp))

  apply (simp add: and_applicable_def)
  apply (intro exI conjI)
  apply (rule refl)
  apply (simp add: appcond_and_rewr)
  apply (simp add: list_ex_is_x_c_inst)
  apply simp
  done

lemma complete_rule_impl_or [simp]:
  "complete_rule_impl set Orrule or_rule"
  apply (simp add: or_rule_def or_srule_def)
  apply (rule complete_rule_impl_abstr)
  apply (clarsimp simp add: orrule_simp)
  apply (erule disjE)
    (* case c1 *)
  apply (rule_tac x="[(Inst x c1)]" in exI)
  apply (rule conjI) apply fastsimp
  apply (drule in_set_conv_decomp [THEN iffD1])
  apply (elim exE)
  apply (simp (no_asm_simp))
  
  apply (intro exI conjI)
  apply (rule refl)
  apply (simp add: appcond_and_rewr)
  apply (simp add: list_ex_is_x_c_inst)
  apply simp
    (* case c2 *)
  apply (rule_tac x="[(Inst x c2)]" in exI)
  apply (rule conjI) apply fastsimp
  apply (drule in_set_conv_decomp [THEN iffD1])
  apply (elim exE)
  apply (simp (no_asm_simp))

  apply (intro exI conjI)
  apply (rule refl)
  apply (simp add: appcond_and_rewr)
  apply (simp add: list_ex_is_x_c_inst)
  apply simp
  done



lemma complete_rule_impl_all [simp]:
  "complete_rule_impl set Allrule all_rule"
  apply (simp add: all_rule_def all_srule_def)
  apply (rule complete_rule_impl_abstr)
  apply (clarsimp simp add: allrule_simp)
  apply (rule_tac x="[(Inst y c1)]" in exI)
  apply (rule conjI) apply fastsimp
  apply (drule in_set_conv_decomp [THEN iffD1])
  apply (elim exE)
  apply (simp (no_asm_simp))
  
  apply (intro exI conjI)
  apply (rule refl)
  apply (simp add: appcond_and_rewr)
  apply (fastsimp simp add: list_ex_is_related_all)
  apply simp
  apply (elim disjE)
    (* case 1 *)
  apply (subgoal_tac "Inst y c1 \<notin> set ys \<and> Rel r x y \<in> set ys")
  prefer 2 apply fastsimp
  apply (simp only: my_rule)
  apply (clarsimp simp add: Let_def image_def)
  apply (fastsimp simp add: is_related_all_test_rew2)
  
    (* case 2 *)
  apply (subgoal_tac "Inst y c1 \<notin> set zs \<and> Rel r x y \<in> set zs")
  prefer 2 apply fastsimp
  apply (simp only: my_rule)
  apply (clarsimp simp add: Let_def image_def)
  apply (fastsimp simp add: is_related_all_test_rew2)
  done


    (*-------------------------------- contains_clash_impl  *)

fun is_neg_inst :: "('ni,'nr,'nc) fact \<Rightarrow> ('ni,'nr,'nc) fact \<Rightarrow> bool"
  where
  "is_neg_inst (Inst x c) f = (f = (Inst x (NotC c)))"
  | "is_neg_inst _ f = False"

lemma [simp]: "is_neg_inst (Inst x c)  (Inst x (NotC c))"
  by simp

fun is_bot_inst :: "('ni,'nr,'nc) fact \<Rightarrow> bool"
  where
  "is_bot_inst (Inst x Bottom) = True"
  | "is_bot_inst _  = False"


fun contains_clash_impl :: "('ni,'nr,'nc) abox_impl \<Rightarrow> bool  "
  where
  " contains_clash_impl AB = ((list_ex  (\<lambda> x. (list_ex (is_neg_inst x) AB)) AB) \<or> (list_ex is_bot_inst AB))"


  (**** those proofs are not optimized **)

lemma [simp] :
  "(list_ex  (\<lambda> x. (list_ex (is_neg_inst x) AB)) AB) \<Longrightarrow> (\<exists> x c. ((Inst x c) \<in> (set AB) \<and> (Inst x (NotC c)) \<in>( set AB)) ) "
  apply (clarsimp  simp add: list_ex_iff)
  apply (case_tac x)
  apply fastsimp+
  done

lemma [simp] :
  "(\<exists> x c. ((Inst x c) \<in> (set AB) \<and> (Inst x (NotC c)) \<in>( set AB)) )\<Longrightarrow> (list_ex  (\<lambda> x. (list_ex (is_neg_inst x) AB)) AB)"
  apply (clarsimp  simp add: list_ex_iff)
  apply (subgoal_tac "is_neg_inst (Inst x c) (Inst x (NotC c))")
  apply blast
  apply simp
  done

lemma [simp] :
  "(\<exists> x c. ((Inst x c) \<in> (set AB) \<and> (Inst x (NotC c)) \<in>( set AB)) ) = (list_ex  (\<lambda> x. (list_ex (is_neg_inst x) AB)) AB)"
  apply (rule iffI)
  apply simp+
  done

lemma [simp]: "list_ex is_bot_inst AB = (\<exists>x. Inst x Bottom \<in> set AB)"
  apply (induct AB)
  apply simp
  apply simp
  apply (case_tac a)
  apply simp
  apply (case_tac concept)
  apply fastsimp+
  done

(*** good proof*)
lemma contains_clash_impl_contains_clash: "contains_clash_impl ab_i = contains_clash (set ab_i)"
  apply (rule iffI)
  apply simp
  apply (clarsimp  simp add: list_ex_iff)
  apply auto
  defer
  apply (clarsimp  simp add: list_ex_iff)
  apply (subgoal_tac "is_neg_inst (Inst x c) (Inst x (NotC c))")
  apply blast
  apply simp
  apply (case_tac x)
  apply fastsimp+
  done


    (* --------------------   TERMINATION ------------------------------  *)


lemma is_related_some_neg_mono:
  "\<lbrakk>set ab \<subseteq> set ab'; (is_related_some_neg x r c ab rel)\<rbrakk>
  \<Longrightarrow> (is_related_some_neg x r c ab' rel)"
  apply (simp add: is_related_all_some_neg)
  apply clarsimp
  apply (rule conjI)
  apply (rule list_ex_mono) apply assumption+
  apply (rule list_ex_mono) apply assumption+
  done

lemma appcond_and_antimono [rule_format]: 
  "\<lbrakk> set ab \<subseteq> set ab'; appcond_and ab' fct \<rbrakk> 
  \<Longrightarrow> appcond_and ab fct"
  by (simp add: appcond_and_rewr) (blast intro: list_ex_mono)

lemma appcond_or_antimono [rule_format]: 
  "\<lbrakk> set ab \<subseteq> set ab'; appcond_or ab' fct \<rbrakk> 
  \<Longrightarrow> appcond_or ab fct"
  by (simp add: appcond_or_rewr) (blast intro: list_ex_mono)

lemma appcond_some_antimono [rule_format]: 
  "\<lbrakk> set ab \<subseteq> set ab'; appcond_some ab' fct \<rbrakk> 
  \<Longrightarrow> appcond_some ab fct"
  apply (simp add: appcond_some_rewr)
  apply clarsimp
  apply (frule list_ex_mono) apply assumption
  apply (frule list_ex_pred_mono [where  ab=ab']) 
  prefer 2 apply blast apply (rule is_related_some_neg_mono) apply assumption+
  done

(*


  (* *** or_srule *** *)
lemma meas_comp_OrC:
  "\<not> list_ex (is_x_c_inst x c1) ab
  \<Longrightarrow> \<not> list_ex (is_x_c_inst x c2) ab
  \<Longrightarrow> meas_comp ab (Inst x (OrC c1 c2)) = (Suc (sizeC c1 + sizeC c2), 0)"
  by (simp add: meas_comp_def del: multiset_of.simps)

lemma measure_decreasing_or_srule:
  "measure_decreasing or_srule"
  apply (clarsimp simp add: or_srule_def appcond_or_rewr
    measure_decreasing_def)
  apply (elim disjE)
  apply (intro conjI)
  apply (simp add: meas_comp_OrC meas_comp_bound)
  apply (simp add: meas_comp_def pair_less_def)
  apply (simp add: meas_comp_OrC meas_comp_bound)
  apply (simp add: meas_comp_def pair_less_def)
  done

lemma pushing_new_facts_or_srule: 
  "pushing_new_facts or_srule"
  apply (clarsimp simp add: pushing_new_facts_def 
    or_srule_def appcond_or_rewr)
  apply (simp add: list_ex_iff)
  apply (elim disjE)
  apply clarsimp+
  done


lemma measure_abox_impl_order_or_rule: 
  "n \<in> set (or_rule abx) \<Longrightarrow> (n, abx) \<in> measure_abox_impl_order"
  by (clarsimp simp add: or_rule_def)
(fast intro: foobar
  pushing_new_facts_or_srule
  measure_decreasing_or_srule)


  (* *** some_srule *** *)
  (* OK*)


lemma meas_comp_SomeC:" (\<not> list_ex ( is_related_some_neg  x r c Ab_i) Ab_i) 
  \<Longrightarrow> meas_comp Ab_i (Inst x (SomeC r c)) = (Suc (sizeC c), 0)"
  by (simp add: meas_comp_def del: multiset_of.simps)
    
  

lemma measure_decreasing_some_srule:
  "measure_decreasing some_srule"
  apply (clarsimp simp add: some_srule_def appcond_some_rewr measure_decreasing_def Let_def )
  apply (clarsimp simp add:meas_comp_SomeC meas_comp_bound)
  apply (simp add: not_list_ex_is_related_some_neg meas_comp_def pair_less_def)
  done

lemma pushing_new_facts_some_srule: 
  "pushing_new_facts some_srule"
  apply (clarsimp simp add: pushing_new_facts_def   some_srule_def appcond_some_rewr)
  apply (clarsimp simp add: not_list_ex_is_related_some_neg Let_def)
  done


lemma measure_abox_impl_order_some_rule: 
  "n \<in> set (some_rule abx) \<Longrightarrow> (n, abx) \<in> measure_abox_impl_order"
  by (clarsimp simp add: some_rule_def)
(fast intro: foobar
  pushing_new_facts_some_srule
  measure_decreasing_some_srule)



 (*** all_srule***)

(* i will try to proof *)
lemma meas_comp_AllC:" meas_comp Ab (Inst x (AllC r c)) =(Suc (sizeC c) , (comp11 x c r Ab) + (comp12 x r (set Ab)))"
  by (simp add: meas_comp_def del: multiset_of.simps)
    
 
    

axioms   measure_decreasing_all_srule:
  "measure_decreasing all_srule"
(*
  apply (clarsimp simp add: all_srule_def appcond_all_rewr measure_decreasing_def Let_def )
  apply (clarsimp simp add:meas_comp_AllC meas_comp_bound)
  apply (clarsimp simp add: comp11_def)
  apply (simp add: not_list_ex_is_related_some_neg meas_comp_def pair_less_def)

 sorry*)
(*
consts  measure_decreasing_all_srule :: " bool"
  "measure_decreasing_all_srule \<equiv>  measure_decreasing all_srule"
*)

lemma pushing_new_facts_all_srule: 
  "pushing_new_facts all_srule"
  apply (clarsimp simp add: pushing_new_facts_def   all_srule_def appcond_all_rewr)
  apply (clarsimp simp add: not_list_ex_is_related_some_neg Let_def)
  done


lemma measure_abox_impl_order_all_rule: 
  "n \<in> set (all_rule abx) \<Longrightarrow> (n, abx) \<in> measure_abox_impl_order"
  by (clarsimp simp add: all_rule_def)
(fast intro: foobar
  pushing_new_facts_all_srule
  measure_decreasing_all_srule)
*)


    (* --------------------   END TERMINATION ------------------------------  *)


constdefs measure_abox_impl_order ::
  "(('ni, 'nr, 'nc) abox_impl * ('ni, 'nr, 'nc) abox_impl) set"
  "measure_abox_impl_order \<equiv> inv_image measure_abox_order set"

lemma wf_measure_abox_impl_order: "wf measure_abox_impl_order"
  by (unfold measure_abox_impl_order_def)
     (intro wf_inv_image wf_measure_abox_order)


 (* Should be homogenized with
       sound_rule_impl_alc_rule_impl 
       after removal of alc_rule_altern
 *)
lemma sound_rule_impl_alc_rule_impl2 [simp]:
  "sound_rule_impl set alc_rule  alc_rule_impl"
sorry

lemma alc_rule_impl_measure_abox_impl_order: 
  "n \<in> set (alc_rule_impl abx) \<Longrightarrow> (n, abx) \<in> measure_abox_impl_order"
apply (simp add: measure_abox_impl_order_def)
apply (rule alc_rule_impl_measure_abox_order)
apply simp
apply (insert sound_rule_impl_alc_rule_impl2)
apply (fastsimp simp add: sound_rule_impl_def)
done

text {* simple depth-first-search strategy, 
  returning all the clash-free irreducible sequents.  *}

function dfs :: "('ni::alloc, 'nr, 'nc) tableau \<Rightarrow> ('ni, 'nr, 'nc) tableau"
  where
  "dfs [] = []"
  | "dfs (abx # abxs) = 
  (if (contains_clash_impl abx)
  then dfs abxs
  else if (is_reducible_abox alc_rule_impl abx)
         then dfs ((alc_rule_impl abx) @ abxs)
         else abx # dfs abxs)"
  by pat_completeness auto
termination
  apply (relation "mult1_list measure_abox_impl_order")
  apply (intro wf_mult1_list wf_measure_abox_impl_order)
  apply (rule mult1_list_hd)
  apply (rule mult1_list_hd_replace) apply (erule alc_rule_impl_measure_abox_impl_order)
  apply (rule mult1_list_hd)
  done



    (***false*)

    (* lemma complete_implementation_and : "complete_implementation set Andrule
    (apply_srule and_rule) " apply (clarsimp simp add :
    complete_implementation_def (* andrule_simp and_rule_def option_case_def*) )
    apply (clarsimp simp add : andrule_simp ) apply (case_tac ai ) apply (clarsimp
    simp add: and_rule_def)

    *)


    (*** for testing *)
    (*
    constdefs "AB_list== [
    (Inst ''x'' (AndC (AtomC ''A'') (AtomC ''B''))) , 
    (Inst ''y'' (AndC (AtomC ''C'') (AtomC ''D'')))]"

    normal_form "appcond_and [] (Inst ''x'' (AndC (AtomC ''A'') (AtomC ''B'')))"

    normal_form "apply_srule and_srule AB_list"

    normal_form "apply_srule and_srule 
    [Inst ''x'' (AtomC ''A''), 
    Inst ''x'' (AtomC ''B''),
    Inst ''x'' (AndC (AtomC ''A'') (AtomC ''B'')),
    Inst ''y'' (AndC (AtomC ''C'') (AtomC ''D''))]"
    normal_form "apply_srule and_srule 
    [Inst ''y'' (AtomC ''C''), 
    Inst ''y'' (AtomC ''D''), 
    Inst ''x'' (AtomC ''A''),
    Inst ''x'' (AtomC ''B''),
    Inst ''x'' (AndC (AtomC ''A'') (AtomC ''B'')),
    Inst ''y'' (AndC (AtomC ''C'') (AtomC ''D''))]"

    normal_form "apply_srule and_srule []"

    constdefs "AB2_list== [
    (Inst ''x'' (OrC (AtomC ''A'') (AtomC ''B''))) , 
    (Inst ''y'' (OrC (AtomC ''C'') (AtomC ''D'')))]"
    *)


end
 
