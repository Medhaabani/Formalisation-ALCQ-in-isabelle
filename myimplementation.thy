theory myimplementation  imports Soundness Completeness
begin

types ('ni,'nr,'nc) abox_impl = 
  "(('ni,'nr,'nc) fact) list"

types ('ni,'nr,'nc) rule_impl = 
  "(('ni,'nr,'nc) abox_impl) \<Rightarrow> ('ni,'nr,'nc) abox_impl list"

types ('ni,'nr,'nc) abstraction = 
  "(('ni,'nr,'nc) abox_impl \<Rightarrow> ('ni,'nr,'nc) abox)"

types ('ni, 'nr, 'nc) tableau  = 
  "('ni, 'nr, 'nc) abox_impl list"


(* Rules  *)

types ('ni, 'nr, 'nc) appcond = 
  "('ni, 'nr, 'nc) abox_impl \<Rightarrow> ('ni, 'nr, 'nc) fact \<Rightarrow> bool"

types ('ni, 'nr, 'nc) action = 
  "(('ni, 'nr, 'nc) abox_impl * ('ni, 'nr, 'nc) fact * ('ni, 'nr, 'nc) abox_impl) \<Rightarrow>
  ('ni, 'nr, 'nc) abox_impl"

datatype ('ni, 'nr, 'nc) srule  = 
  Rule " ('ni, 'nr, 'nc) appcond * (('ni, 'nr, 'nc) action list)"

(** some properties **)

(*
-- should rather be completeness: no potential solutions are lost.
 constdefs 
   correct_implementation :: "(('ni,'nr,'nc) abox_impl \<Rightarrow> ('ni,'nr,'nc) abox) \<Rightarrow> (('ni,'nr,'nc) rule) \<Rightarrow> (('ni,'nr,'nc) rule_impl) \<Rightarrow> bool"
   "correct_implementation abstr r r_impl ==  \<forall>  ai ai'. (r (abstr ai) (abstr ai')) \<longrightarrow>  ai' \<in> set (r_impl ai) "

 -- corresponds to soundness below
 constdefs 
   complete_implementation :: "(('ni,'nr,'nc) abox_impl \<Rightarrow> ('ni,'nr,'nc) abox) \<Rightarrow> (('ni,'nr,'nc) rule) \<Rightarrow> (('ni,'nr,'nc) rule_impl) \<Rightarrow> bool"
   "complete_implementation abstr r r_impl ==  \<forall>  ai ai'.  ai' \<in> set (r_impl ai) \<longrightarrow> (r (abstr ai) (abstr ai'))"
*)

   (* "sound" means: all successor tableaux generated by the rule implementation 
   also have to be generated by the rule itself.
   *)
constdefs 
   complete_rule_impl :: "('ni,'nr,'nc) abstraction
   \<Rightarrow> (('ni,'nr,'nc) rule) \<Rightarrow> (('ni,'nr,'nc) rule_impl) \<Rightarrow> bool"
   "complete_rule_impl abstr r r_impl \<equiv>
 \<forall>  ai ai'. (r (abstr ai) (abstr ai')) \<longrightarrow>  ai' \<in> set (r_impl ai) "

(* this is other definition we use set inclusion better 
to not consdere the ordre (2 lists are equal if they are identique , ordre also is important) wich not considered in set *)
constdefs 
   complete_rule_impl_set :: "('ni,'nr,'nc) abstraction
   \<Rightarrow> (('ni,'nr,'nc) rule) \<Rightarrow> (('ni,'nr,'nc) rule_impl) \<Rightarrow> bool"
   "complete_rule_impl_set abstr r r_impl \<equiv>
 \<forall>  ai ai'. (r (abstr ai) (abstr ai')) \<longrightarrow>  set ai' \<in>  (set` set (r_impl ai))"



 constdefs 
   sound_rule_impl :: "('ni,'nr,'nc) abstraction
   \<Rightarrow> (('ni,'nr,'nc) rule) \<Rightarrow> (('ni,'nr,'nc) rule_impl) \<Rightarrow> bool"
   "sound_rule_impl abstr r r_impl \<equiv> 
   \<forall> ai ai'. (ai' \<in> set (r_impl ai)) \<longrightarrow> r (abstr ai) (abstr ai')"

   (* see Tableau.thy *)
definition satisfies_abox :: 
  "(('ni Interp_inst) * (('nr, 'nc) Interp) ) \<Rightarrow> (('ni,'nr,'nc) abox) \<Rightarrow> bool"
   where
     "satisfies_abox i ab = (\<forall> f \<in> ab. satisfiable_fact i f)"

definition satisfies_abox_impl :: 
  "('ni,'nr,'nc) abstraction \<Rightarrow> 
  (('ni Interp_inst) * (('nr, 'nc) Interp) ) \<Rightarrow> (('ni,'nr,'nc) abox_impl) \<Rightarrow> bool"
   where
     "satisfies_abox_impl abstr i ai = (\<forall> f \<in> abstr ai. satisfiable_fact i f)"

definition satisfiable_abox_impl :: 
  "('ni,'nr,'nc) abstraction \<Rightarrow> (('ni,'nr,'nc) abox_impl) \<Rightarrow> bool"
   where
     "satisfiable_abox_impl abstr ai = (\<exists> i. satisfies_abox_impl abstr i ai)"

constdefs
  sound_impl :: "('ni,'nr,'nc) abstraction \<Rightarrow> ('ni,'nr,'nc) rule_impl \<Rightarrow> bool"
  "sound_impl abstr r_impl == 
  \<forall> ai1 ai2. ai2 \<in> set (r_impl ai1) \<longrightarrow> 
  satisfiable_abox_impl abstr ai2 \<longrightarrow> satisfiable_abox_impl abstr ai1"

lemma sound_rule_impl_reduction:
  "sound_rule_impl abstr r r_impl \<Longrightarrow> sound r \<Longrightarrow> sound_impl abstr r_impl"
apply (clarsimp simp add: sound_rule_impl_def sound_def sound_impl_def)
apply (simp add: satisfiable_abox_impl_def)
apply (clarsimp simp add: satisfiable_abox_def)
apply (clarsimp simp add: satisfies_abox_impl_def)
apply fastsimp
done

(*** Rules implementation ***)

consts
  split_appcond  :: 
  "(('ni, 'nr, 'nc) appcond) 
  \<Rightarrow> ('ni, 'nr, 'nc) abox_impl
  \<Rightarrow> ('ni, 'nr, 'nc) abox_impl
  \<Rightarrow> ('ni, 'nr, 'nc) abox_impl
  \<Rightarrow> ((('ni, 'nr, 'nc) abox_impl * ('ni, 'nr, 'nc) fact * ('ni, 'nr, 'nc) abox_impl)list)" 
primrec
  "split_appcond appc prefix [] ab = []"
  "split_appcond appc prefix (ft#suffix) ab = 
    (if (appc ab ft)
    then (prefix, ft, suffix) #
         (split_appcond appc (prefix @ [ft]) suffix ab)    
    else (split_appcond appc (prefix @ [ft]) suffix ab))"


lemma split_appcond_invariant [rule_format]:
  "\<forall> prefix ab. 
  (prefix @ suffix = ab \<longrightarrow>
  (\<forall> (p, f, s) \<in> set (split_appcond appc prefix suffix ab).
  (p @ [f] @ s = ab \<and> appc ab f)))"
apply (induct suffix)
apply simp
apply (clarsimp simp add: split_def)
apply (rename_tac a suffix prefix p f s)
apply (drule_tac x="prefix@[a]" in spec)
apply fastsimp
done

lemma split_appcond_invariant2 [rule_format]:
  "\<forall> prefix ab. 
  (ab = prefix @ suffix \<longrightarrow>
  (\<forall> p f s. 
  (p, f, s) \<in> set (split_appcond appc prefix suffix ab) \<longrightarrow> 
  (p @ [f] @ s = ab \<and> appc ab f)))"
apply (induct suffix)
apply simp
apply (clarsimp simp add: split_def)
apply (rename_tac a suffix prefix p f s)
apply (drule_tac x="prefix@[a]" in spec)
apply (drule_tac x=p in spec)
apply (drule_tac x=f in spec)
apply (drule_tac x=s in spec)
apply simp
done

lemma split_appcond_invariant3:
    "\<lbrakk>(p, f, s) \<in> set (split_appcond appc prefix suffix ab);
      ab = prefix @ suffix \<rbrakk>
    \<Longrightarrow> p @ [f] @ s = ab \<and> appc ab f"
apply (rule split_appcond_invariant2) apply assumption+
done

(*
fun  lift_appcond  ::" (('ni, 'nr, 'nc) appcond) 
                       \<Rightarrow> ('ni, 'nr, 'nc) abox_impl
                         \<Rightarrow>('ni, 'nr, 'nc) abox_impl
                            \<Rightarrow> (('ni, 'nr, 'nc) fact option )" 
  where
  "lift_appcond appc Ab_i  [] =  None"
  | "lift_appcond appc  Ab_i (fct # fcts) = 
     ( case (appc Ab_i  fct) of  
                    None  \<Rightarrow> lift_appcond appc Ab_i fcts  
                  | Some fct1  \<Rightarrow> Some fct1) "
*)

thm split_appcond_invariant


fun is_x_c_inst :: "'ni \<Rightarrow> ('nr, 'nc) concept \<Rightarrow> ('ni, 'nr, 'nc) fact\<Rightarrow> bool"
  where 
  "is_x_c_inst x c f =  (f = Inst x c)"


lemma list_ex_is_x_c_inst:
  "(list_ex (is_x_c_inst x c) xs) =  ((Inst x c) \<in> set xs)"
by (induct xs) auto


(**** And rule ***)

fun appcond_and :: "('ni, 'nr, 'nc) appcond"
  where
    "appcond_and Ab_i (Inst x (AndC c1 c2)) = 
      ((\<not> (list_ex (is_x_c_inst x c1) Ab_i )) \<or> \<not> (list_ex (is_x_c_inst x c2) Ab_i ))"
    |"appcond_and Ab_i  _  = False"

lemma appcond_and_rewr:
  "appcond_and Ab_i fct = 
(\<exists> x c1 c2. (fct = (Inst x (AndC c1 c2)) \<and> ((\<not> (list_ex (is_x_c_inst x c1) Ab_i )) \<or> \<not> (list_ex (is_x_c_inst x c2) Ab_i ))))"
apply (case_tac fct)
apply (case_tac concept)
apply simp_all
done

(*
fun  action_and :: "('ni, 'nr, 'nc) abox_impl \<Rightarrow> ('ni, 'nr, 'nc) fact \<Rightarrow> ('ni, 'nr, 'nc) tableau "
  where
  "action_and  Ab_i (Inst x (AndC c1 c2)) =  [(Inst x c1)#((Inst x c2)#Ab_i)]"
  | "action_and  Ab_i  _  = []"
*)

fun action_and :: "('ni, 'nr, 'nc) action"
where
  "action_and (prefix, (Inst x (AndC c1 c2)), suffix) = 
    [(Inst x c1), (Inst x c2)] @ prefix @ [Inst x (AndC c1 c2)] @ suffix"
  | "action_and _  = []"


constdefs and_rule ::"('ni, 'nr, 'nc) srule" 
  "and_rule == Rule (appcond_and, [action_and])"

(**** Or rule ***)

fun appcond_or :: "('ni, 'nr, 'nc) appcond"
  where
    "appcond_or Ab_i (Inst x (OrC c1 c2)) = 
      ((\<not> (list_ex (is_x_c_inst x c1) Ab_i )) \<and> \<not> (list_ex (is_x_c_inst x c2) Ab_i ))"
    |"appcond_or Ab_i  _  = False"

lemma appcond_or_rewr:
  "appcond_or  Ab_i fct = 
(\<exists> x c1 c2. (fct = (Inst x (OrC c1 c2)) \<and> ((\<not> (list_ex (is_x_c_inst x c1) Ab_i )) \<and> \<not> (list_ex (is_x_c_inst x c2) Ab_i ))))"
apply (case_tac fct)
apply (case_tac concept)
apply simp_all
done

(*
fun  action_and :: "('ni, 'nr, 'nc) abox_impl \<Rightarrow> ('ni, 'nr, 'nc) fact \<Rightarrow> ('ni, 'nr, 'nc) tableau "
  where
  "action_and  Ab_i (Inst x (AndC c1 c2)) =  [(Inst x c1)#((Inst x c2)#Ab_i)]"
  | "action_and  Ab_i  _  = []"
*)

fun action_or_left:: "('ni, 'nr, 'nc) action"
where
  "action_or_left (prefix, (Inst x (OrC c1 c2)), suffix) = 
    [(Inst x c1)] @ prefix @ [Inst x (OrC c1 c2)] @ suffix"
  | "action_or_left _  = []"

fun action_or_right:: "('ni, 'nr, 'nc) action"
where
  "action_or_right (prefix, (Inst x (OrC c1 c2)), suffix) = 
    [(Inst x c2)] @ prefix @ [Inst x (OrC c1 c2)] @ suffix"
  | "action_or_right _  = []"

constdefs or_rule::"('ni, 'nr, 'nc) srule" 
  "or_rule == Rule (appcond_or , [action_or_left, action_or_left])"




(*** (to do) do the same for others rules *)

fun apply_rule :: 
  "('ni, 'nr, 'nc) abox_impl \<Rightarrow> ('ni, 'nr, 'nc) srule \<Rightarrow>('ni, 'nr, 'nc) tableau " 
  where 
  "apply_rule  ab_i (Rule(appc, act_list))  = 
   (case act_list of 
    [] \<Rightarrow> [ab_i]
  | act # acts \<Rightarrow>  (map act (split_appcond appc [] ab_i ab_i)) @ (map act (split_appcond appc [] ab_i ab_i))@ apply_rule  ab_i (Rule(appc, acts)) ) "
end

(*** here indeterministe with tow action, this used for or_rule 
best if we define list of action for rule*)
fun apply_rule_ind :: 
  "(('ni, 'nr, 'nc) srule * ('ni, 'nr, 'nc) srule) \<Rightarrow>('ni, 'nr, 'nc) abox_impl \<Rightarrow> ('ni, 'nr, 'nc) tableau " 
  where 
  "apply_rule_ind ((Rule(appc, act)), (Rule(appc1, act1))) ab_i = 
  (map act (split_appcond appc [] ab_i ab_i)) @ (map act1 (split_appcond appc1 [] ab_i ab_i)) "


term "apply_rule and_rule"
term "apply_rule_ind (or_rule_left, or_rule_right)"

lemma   correct_implementation_and :
  "sound_rule_impl set Andrule (apply_rule and_rule) "
  apply (clarsimp simp add : sound_rule_impl_def)
  apply (clarsimp simp add: and_rule_def)
  apply (frule split_appcond_invariant3)
  apply simp
  apply (clarsimp simp add: appcond_and_rewr)
  apply (rule mk_andrule) apply fastsimp
  apply (fastsimp simp add: list_ex_is_x_c_inst)
  apply blast
  done


(*
lemma   complete_implementation_and :
  "complete_rule_impl_set set Andrule (apply_rule and_rule) "
  apply (clarsimp simp add : complete_rule_impl_set_def)
  apply (clarsimp simp add: and_rule_def )
 apply(case_tac ai)
 apply (simp add: andrule_simp)
 apply (case_tac a)
 defer
 apply simp
 apply (clarsimp simp add: appcond_and_rewr andrule_simp)  
apply auto
  apply (simp add: split_appcond_invariant)
apply auto
 apply (clarsimp simp add: andrule_simp)
apply (clarsimp simp add: list_ex_is_x_c_inst)
  apply (rule split_appcond_invariant3)
  apply (frule split_appcond_invariant3)
  apply simp
  apply (clarsimp simp add: appcond_and_rewr)
  apply (rule mk_andrule) apply fastsimp
  apply (fastsimp simp add: list_ex_is_x_c_inst)
  apply blast
  done

*)
(* contains_clash_impl  *)

fun is_neg_inst :: "('ni,'nr,'nc) fact \<Rightarrow> ('ni,'nr,'nc) fact \<Rightarrow> bool"
where
  "is_neg_inst (Inst x c) f = (f = (Inst x (NotC c)))"
| "is_neg_inst _ f = False"

lemma [simp]: "is_neg_inst (Inst x c)  (Inst x (NotC c))"
  by simp

fun is_bot_inst :: "('ni,'nr,'nc) fact \<Rightarrow> bool"
where
  "is_bot_inst (Inst x Bottom) = True"
| "is_bot_inst _  = False"


fun contains_clash_impl :: "('ni,'nr,'nc) abox_impl \<Rightarrow> bool  "
  where
  " contains_clash_impl AB = ((list_ex  (\<lambda> x. (list_ex (is_neg_inst x) AB)) AB) \<or> (list_ex is_bot_inst AB))"


(**** those proofs are not optimized **)

lemma [simp] :
  "(list_ex  (\<lambda> x. (list_ex (is_neg_inst x) AB)) AB) \<Longrightarrow> (\<exists> x c. ((Inst x c) \<in> (set AB) \<and> (Inst x (NotC c)) \<in>( set AB)) ) "
  apply (clarsimp  simp add: list_ex_iff)
  apply (case_tac x)
  apply fastsimp+
  done

lemma [simp] :
  "(\<exists> x c. ((Inst x c) \<in> (set AB) \<and> (Inst x (NotC c)) \<in>( set AB)) )\<Longrightarrow> (list_ex  (\<lambda> x. (list_ex (is_neg_inst x) AB)) AB)"
  apply (clarsimp  simp add: list_ex_iff)
  apply (subgoal_tac "is_neg_inst (Inst x c) (Inst x (NotC c))")
  apply blast
  apply simp
  done

lemma [simp] :
  "(\<exists> x c. ((Inst x c) \<in> (set AB) \<and> (Inst x (NotC c)) \<in>( set AB)) ) = (list_ex  (\<lambda> x. (list_ex (is_neg_inst x) AB)) AB)"
  apply (rule iffI)
  apply simp+
  done

lemma [simp]: "list_ex is_bot_inst AB = (\<exists>x. Inst x Bottom \<in> set AB)"
  apply (induct AB)
  apply simp
  apply simp
  apply (case_tac a)
  apply simp
  apply (case_tac concept)
  apply fastsimp+
  done

(*** good proof*)
lemma contains_clash_impl_contains_clash: "contains_clash_impl ab_i = contains_clash (set ab_i)"
  apply (rule iffI)
  apply simp
  apply (clarsimp  simp add: list_ex_iff)
  apply auto
  defer
  apply (clarsimp  simp add: list_ex_iff)
  apply (subgoal_tac "is_neg_inst (Inst x c) (Inst x (NotC c))")
  apply blast
  apply simp
  apply (case_tac x)
  apply fastsimp+
  done

    (***false*)

    (* lemma complete_implementation_and : "complete_implementation set Andrule
    (apply_rule and_rule) " apply (clarsimp simp add :
    complete_implementation_def (* andrule_simp and_rule_def option_case_def*) )
    apply (clarsimp simp add : andrule_simp ) apply (case_tac ai ) apply (clarsimp
    simp add: and_rule_def)

    *)


    (*** for testing *)

constdefs "AB_list== [
  (Inst ''x'' (AndC (AtomC ''A'') (AtomC ''B''))) , 
  (Inst ''y'' (AndC (AtomC ''C'') (AtomC ''D'')))]"
normal_form "appcond_and [] (Inst ''x'' (AndC (AtomC ''A'') (AtomC ''B'')))"
normal_form "apply_rule and_rule AB_list"
normal_form "apply_rule and_rule [Inst ''x'' (AtomC ''A''), Inst ''x'' (AtomC ''B''), Inst ''x'' (AndC (AtomC ''A'') (AtomC ''B'')), Inst ''y'' (AndC (AtomC ''C'') (AtomC ''D''))]"
normal_form "apply_rule and_rule [Inst ''y'' (AtomC ''C''), Inst ''y'' (AtomC ''D''), Inst ''x'' (AtomC ''A''), Inst ''x'' (AtomC ''B''),
   Inst ''x'' (AndC (AtomC ''A'') (AtomC ''B'')), Inst ''y'' (AndC (AtomC ''C'') (AtomC ''D''))]"
normal_form "apply_rule and_rule []"
normal_form " (apply_rule and_rule) [(Inst (0::nat) (AndC (AtomC (1::nat)) (AtomC 2))), (Inst (4::nat) (AndC (AtomC (1::nat)) (AtomC (2::nat))))]" 

normal_form "(apply_rule and_rule)[Inst 0 (AtomC (Suc 0)), Inst 0 (AtomC (Suc (Suc 0))), Inst 0 (AndC (AtomC (Suc 0)) (AtomC (Suc (Suc 0)))),
  Inst (Suc (Suc (Suc (Suc 0)))) (AndC (AtomC (Suc 0)) (AtomC (Suc (Suc 0))))]"
constdefs "AB2_list== [
  (Inst ''x'' (OrC (AtomC ''A'') (AtomC ''B''))) , 
  (Inst ''y'' (OrC (AtomC ''C'') (AtomC ''D'')))]"
normal_form "apply_rule_ind (or_rule_left, or_rule_right) AB2_list"
normal_form "apply_rule_ind (or_rule_left, or_rule_right)[Inst ''x'' (AtomC ''A''), Inst ''x'' (OrC (AtomC ''A'') (AtomC ''B'')), Inst ''y'' (AndC (AtomC ''C'') (AtomC ''D''))] "
lemma   correct_implementation_and :
  "correct_implementation set  Andrule (apply_rule and_rule) "
  apply (clarsimp simp add : correct_implementation_def) (*  andrule_simp and_rule_def*)
  apply (case_tac ai )
  apply (clarsimp simp add :  andrule_simp and_rule_def ) 
  apply (clarsimp simp add :  andrule_simp and_rule_def )
  apply ( case_tac a) defer
  apply clarsimp
  apply clarsimp
 




end
correct_implementation :: "(('ni,'nr,'nc) abox_impl \<Rightarrow> ('ni,'nr,'nc) abox) \<Rightarrow> (('ni,'nr,'nc) rule) \<Rightarrow> (('ni,'nr,'nc) rule_impl) \<Rightarrow> bool"
   "correct_implementation abstr r r_impl ==  \<forall>  ai ai'. (r (abstr ai) (abstr ai')) \<longrightarrow>  ai' \<in> set (r_impl ai) "

end
 









(* faux 
constdefs 
"correct_implementation abstr r r_impl ==  \<forall>  a a'. (r a a') \<longrightarrow>  (abstr a') \<in> set (r_impl (abstr a)) "
  a  reconsiderer
constdefs 
"complete_implementation abstr r r_impl ==  \<forall>  a a'. (r_impl (abstr a) (abstr a')) \<longrightarrow> (r a a')"
*)
